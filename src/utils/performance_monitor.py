# -*- coding: utf-8 -*-
"""
Ïã§ÏãúÍ∞Ñ ÏÑ±Îä• Î™®ÎãàÌÑ∞ÎßÅ ÏãúÏä§ÌÖú
Ïπ¥Ìéò24 ÏûêÎèôÌôî ÏûëÏóÖÏùò ÏÑ±Îä•ÏùÑ Ïã§ÏãúÍ∞ÑÏúºÎ°ú Î™®ÎãàÌÑ∞ÎßÅÌïòÍ≥† Î∂ÑÏÑù
"""

import time
import json
import psutil
import threading
from datetime import datetime, timedelta
from typing import Dict, List, Optional
import logging

logger = logging.getLogger(__name__)

class PerformanceMonitor:
    """Ïã§ÏãúÍ∞Ñ ÏÑ±Îä• Î™®ÎãàÌÑ∞ÎßÅ ÏãúÏä§ÌÖú"""
    
    def __init__(self, monitoring_interval: float = 1.0):
        self.monitoring_interval = monitoring_interval
        self.is_monitoring = False
        self.monitor_thread = None
        
        # ÏÑ±Îä• Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû•
        self.metrics_history = []
        self.operation_metrics = {}
        self.system_metrics = []
        
        # ÏûÑÍ≥ÑÍ∞í ÏÑ§Ï†ï
        self.thresholds = {
            'cpu_warning': 70,
            'cpu_critical': 85,
            'memory_warning': 75,
            'memory_critical': 90,
            'operation_timeout_warning': 10,
            'operation_timeout_critical': 20
        }
        
        # ÏïåÎ¶º ÏΩúÎ∞±
        self.alert_callbacks = []
    
    def start_monitoring(self):
        """Î™®ÎãàÌÑ∞ÎßÅ ÏãúÏûë"""
        if self.is_monitoring:
            logger.warning("Ïù¥ÎØ∏ Î™®ÎãàÌÑ∞ÎßÅÏù¥ Ïã§Ìñâ Ï§ëÏûÖÎãàÎã§.")
            return
        
        self.is_monitoring = True
        self.monitor_thread = threading.Thread(target=self._monitoring_loop, daemon=True)
        self.monitor_thread.start()
        logger.info("üîç ÏÑ±Îä• Î™®ÎãàÌÑ∞ÎßÅ ÏãúÏûë")
    
    def stop_monitoring(self):
        """Î™®ÎãàÌÑ∞ÎßÅ Ï§ëÏßÄ"""
        self.is_monitoring = False
        if self.monitor_thread:
            self.monitor_thread.join(timeout=2)
        logger.info("‚èπÔ∏è ÏÑ±Îä• Î™®ÎãàÌÑ∞ÎßÅ Ï§ëÏßÄ")
    
    def record_operation_start(self, operation_name: str, operation_id: str = None):
        """ÏûëÏóÖ ÏãúÏûë Í∏∞Î°ù"""
        if not operation_id:
            operation_id = f"{operation_name}_{int(time.time())}"
        
        self.operation_metrics[operation_id] = {
            'name': operation_name,
            'start_time': time.time(),
            'end_time': None,
            'duration': None,
            'success': None,
            'memory_start': psutil.virtual_memory().percent,
            'cpu_start': psutil.cpu_percent(),
            'details': {}
        }
        
        logger.debug(f"üìä ÏûëÏóÖ ÏãúÏûë Í∏∞Î°ù: {operation_name} (ID: {operation_id})")
        return operation_id
    
    def record_operation_end(self, operation_id: str, success: bool = True, details: Dict = None):
        """ÏûëÏóÖ Ï¢ÖÎ£å Í∏∞Î°ù"""
        if operation_id not in self.operation_metrics:
            logger.warning(f"Ïïå Ïàò ÏóÜÎäî ÏûëÏóÖ ID: {operation_id}")
            return
        
        operation = self.operation_metrics[operation_id]
        operation['end_time'] = time.time()
        operation['duration'] = operation['end_time'] - operation['start_time']
        operation['success'] = success
        operation['memory_end'] = psutil.virtual_memory().percent
        operation['cpu_end'] = psutil.cpu_percent()
        
        if details:
            operation['details'].update(details)
        
        # ÏÑ±Îä• Î∂ÑÏÑù
        self._analyze_operation_performance(operation_id)
        
        logger.debug(f"üìä ÏûëÏóÖ Ï¢ÖÎ£å Í∏∞Î°ù: {operation['name']} (ÏÜåÏöîÏãúÍ∞Ñ: {operation['duration']:.2f}Ï¥à)")
    
    def get_current_metrics(self) -> Dict:
        """ÌòÑÏû¨ ÏãúÏä§ÌÖú Î©îÌä∏Î¶≠ Î∞òÌôò"""
        try:
            cpu_percent = psutil.cpu_percent(interval=0.1)
            memory = psutil.virtual_memory()
            disk = psutil.disk_usage('/')
            
            metrics = {
                'timestamp': time.time(),
                'cpu_percent': cpu_percent,
                'memory_percent': memory.percent,
                'memory_available_gb': memory.available / (1024**3),
                'disk_percent': disk.percent,
                'disk_free_gb': disk.free / (1024**3),
                'active_operations': len([op for op in self.operation_metrics.values() if op['end_time'] is None])
            }
            
            return metrics
            
        except Exception as e:
            logger.error(f"Î©îÌä∏Î¶≠ ÏàòÏßë Ïã§Ìå®: {e}")
            return {}
    
    def get_performance_summary(self, hours: int = 1) -> Dict:
        """ÏÑ±Îä• ÏöîÏïΩ Ï†ïÎ≥¥ Î∞òÌôò"""
        cutoff_time = time.time() - (hours * 3600)
        
        # ÏµúÍ∑º ÏûëÏóÖÎì§ ÌïÑÌÑ∞ÎßÅ
        recent_operations = [
            op for op in self.operation_metrics.values()
            if op['start_time'] >= cutoff_time and op['end_time'] is not None
        ]
        
        if not recent_operations:
            return {"message": f"ÏµúÍ∑º {hours}ÏãúÍ∞Ñ ÎèôÏïà ÏôÑÎ£åÎêú ÏûëÏóÖÏù¥ ÏóÜÏäµÎãàÎã§."}
        
        # ÌÜµÍ≥Ñ Í≥ÑÏÇ∞
        total_operations = len(recent_operations)
        successful_operations = len([op for op in recent_operations if op['success']])
        success_rate = (successful_operations / total_operations) * 100
        
        durations = [op['duration'] for op in recent_operations]
        avg_duration = sum(durations) / len(durations)
        max_duration = max(durations)
        min_duration = min(durations)
        
        # ÏûëÏóÖÎ≥Ñ ÌÜµÍ≥Ñ
        operation_stats = {}
        for op in recent_operations:
            name = op['name']
            if name not in operation_stats:
                operation_stats[name] = {'count': 0, 'total_duration': 0, 'success_count': 0}
            
            operation_stats[name]['count'] += 1
            operation_stats[name]['total_duration'] += op['duration']
            if op['success']:
                operation_stats[name]['success_count'] += 1
        
        # ÌèâÍ∑† Í≥ÑÏÇ∞
        for name, stats in operation_stats.items():
            stats['avg_duration'] = stats['total_duration'] / stats['count']
            stats['success_rate'] = (stats['success_count'] / stats['count']) * 100
        
        return {
            'period_hours': hours,
            'total_operations': total_operations,
            'success_rate': success_rate,
            'avg_duration': avg_duration,
            'max_duration': max_duration,
            'min_duration': min_duration,
            'operation_breakdown': operation_stats
        }
    
    def get_performance_alerts(self) -> List[Dict]:
        """ÏÑ±Îä• ÏïåÎ¶º Î™©Î°ù Î∞òÌôò"""
        alerts = []
        current_metrics = self.get_current_metrics()
        
        if not current_metrics:
            return alerts
        
        # CPU ÏÇ¨Ïö©Î•† Ï≤¥ÌÅ¨
        cpu_percent = current_metrics.get('cpu_percent', 0)
        if cpu_percent >= self.thresholds['cpu_critical']:
            alerts.append({
                'type': 'CRITICAL',
                'category': 'CPU',
                'message': f"CPU ÏÇ¨Ïö©Î•†Ïù¥ Îß§Ïö∞ ÎÜíÏäµÎãàÎã§: {cpu_percent:.1f}%",
                'value': cpu_percent,
                'threshold': self.thresholds['cpu_critical']
            })
        elif cpu_percent >= self.thresholds['cpu_warning']:
            alerts.append({
                'type': 'WARNING',
                'category': 'CPU',
                'message': f"CPU ÏÇ¨Ïö©Î•†Ïù¥ ÎÜíÏäµÎãàÎã§: {cpu_percent:.1f}%",
                'value': cpu_percent,
                'threshold': self.thresholds['cpu_warning']
            })
        
        # Î©îÎ™®Î¶¨ ÏÇ¨Ïö©Î•† Ï≤¥ÌÅ¨
        memory_percent = current_metrics.get('memory_percent', 0)
        if memory_percent >= self.thresholds['memory_critical']:
            alerts.append({
                'type': 'CRITICAL',
                'category': 'MEMORY',
                'message': f"Î©îÎ™®Î¶¨ ÏÇ¨Ïö©Î•†Ïù¥ Îß§Ïö∞ ÎÜíÏäµÎãàÎã§: {memory_percent:.1f}%",
                'value': memory_percent,
                'threshold': self.thresholds['memory_critical']
            })
        elif memory_percent >= self.thresholds['memory_warning']:
            alerts.append({
                'type': 'WARNING',
                'category': 'MEMORY',
                'message': f"Î©îÎ™®Î¶¨ ÏÇ¨Ïö©Î•†Ïù¥ ÎÜíÏäµÎãàÎã§: {memory_percent:.1f}%",
                'value': memory_percent,
                'threshold': self.thresholds['memory_warning']
            })
        
        # Ïû•ÏãúÍ∞Ñ Ïã§Ìñâ ÏûëÏóÖ Ï≤¥ÌÅ¨
        current_time = time.time()
        for op_id, op in self.operation_metrics.items():
            if op['end_time'] is None:  # Ïã§Ìñâ Ï§ëÏù∏ ÏûëÏóÖ
                duration = current_time - op['start_time']
                if duration >= self.thresholds['operation_timeout_critical']:
                    alerts.append({
                        'type': 'CRITICAL',
                        'category': 'OPERATION',
                        'message': f"ÏûëÏóÖÏù¥ ÎÑàÎ¨¥ Ïò§Îûò Ïã§ÌñâÎêòÍ≥† ÏûàÏäµÎãàÎã§: {op['name']} ({duration:.1f}Ï¥à)",
                        'value': duration,
                        'threshold': self.thresholds['operation_timeout_critical'],
                        'operation_id': op_id
                    })
                elif duration >= self.thresholds['operation_timeout_warning']:
                    alerts.append({
                        'type': 'WARNING',
                        'category': 'OPERATION',
                        'message': f"ÏûëÏóÖ Ïã§Ìñâ ÏãúÍ∞ÑÏù¥ ÍπÅÎãàÎã§: {op['name']} ({duration:.1f}Ï¥à)",
                        'value': duration,
                        'threshold': self.thresholds['operation_timeout_warning'],
                        'operation_id': op_id
                    })
        
        return alerts
    
    def export_metrics(self, filename: str = None) -> str:
        """Î©îÌä∏Î¶≠ Îç∞Ïù¥ÌÑ∞ ÎÇ¥Î≥¥ÎÇ¥Í∏∞"""
        if not filename:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"performance_metrics_{timestamp}.json"
        
        export_data = {
            'export_timestamp': time.time(),
            'system_metrics': self.system_metrics[-1000:],  # ÏµúÍ∑º 1000Í∞ú
            'operation_metrics': dict(self.operation_metrics),
            'thresholds': self.thresholds,
            'summary': self.get_performance_summary(24)  # 24ÏãúÍ∞Ñ ÏöîÏïΩ
        }
        
        try:
            with open(filename, 'w', encoding='utf-8') as f:
                json.dump(export_data, f, indent=2, ensure_ascii=False)
            
            logger.info(f"üìÅ ÏÑ±Îä• Î©îÌä∏Î¶≠ ÎÇ¥Î≥¥ÎÇ¥Í∏∞ ÏôÑÎ£å: {filename}")
            return filename
            
        except Exception as e:
            logger.error(f"Î©îÌä∏Î¶≠ ÎÇ¥Î≥¥ÎÇ¥Í∏∞ Ïã§Ìå®: {e}")
            return None
    
    def _monitoring_loop(self):
        """Î™®ÎãàÌÑ∞ÎßÅ Î£®ÌîÑ"""
        while self.is_monitoring:
            try:
                metrics = self.get_current_metrics()
                if metrics:
                    self.system_metrics.append(metrics)
                    
                    # ÏµúÍ∑º 10000Í∞ú Î©îÌä∏Î¶≠Îßå Ïú†ÏßÄ
                    if len(self.system_metrics) > 10000:
                        self.system_metrics = self.system_metrics[-10000:]
                    
                    # ÏïåÎ¶º Ï≤¥ÌÅ¨
                    alerts = self.get_performance_alerts()
                    for alert in alerts:
                        self._trigger_alert(alert)
                
                time.sleep(self.monitoring_interval)
                
            except Exception as e:
                logger.error(f"Î™®ÎãàÌÑ∞ÎßÅ Î£®ÌîÑ Ïò§Î•ò: {e}")
                time.sleep(self.monitoring_interval)
    
    def _analyze_operation_performance(self, operation_id: str):
        """ÏûëÏóÖ ÏÑ±Îä• Î∂ÑÏÑù"""
        operation = self.operation_metrics[operation_id]
        duration = operation['duration']
        name = operation['name']
        
        # ÏÑ±Îä• ÏûÑÍ≥ÑÍ∞í Ï≤¥ÌÅ¨
        if duration > self.thresholds['operation_timeout_critical']:
            logger.warning(f"‚ö†Ô∏è ÏûëÏóÖ ÏÑ±Îä• Í≤ΩÍ≥†: {name} - {duration:.2f}Ï¥à (ÏûÑÍ≥ÑÍ∞í: {self.thresholds['operation_timeout_critical']}Ï¥à)")
        
        # Î©îÎ™®Î¶¨ ÏÇ¨Ïö©Îüâ Î≥ÄÌôî Ï≤¥ÌÅ¨
        memory_change = operation.get('memory_end', 0) - operation.get('memory_start', 0)
        if memory_change > 10:  # 10% Ïù¥ÏÉÅ Ï¶ùÍ∞Ä
            logger.warning(f"üß† Î©îÎ™®Î¶¨ ÏÇ¨Ïö©Îüâ Ï¶ùÍ∞Ä: {name} - {memory_change:.1f}%")
    
    def _trigger_alert(self, alert: Dict):
        """ÏïåÎ¶º Ìä∏Î¶¨Í±∞"""
        # Ï§ëÎ≥µ ÏïåÎ¶º Î∞©ÏßÄ (Í∞ôÏùÄ Ïπ¥ÌÖåÍ≥†Î¶¨Ïùò ÏïåÎ¶ºÏù¥ ÏµúÍ∑º 1Î∂Ñ ÎÇ¥Ïóê Î∞úÏÉùÌñàÎäîÏßÄ Ï≤¥ÌÅ¨)
        current_time = time.time()
        recent_alerts = [
            m for m in self.system_metrics[-60:]  # ÏµúÍ∑º 60Ï¥à
            if 'alerts' in m and any(
                a['category'] == alert['category'] and a['type'] == alert['type']
                for a in m.get('alerts', [])
            )
        ]
        
        if recent_alerts:
            return  # Ï§ëÎ≥µ ÏïåÎ¶º Î∞©ÏßÄ
        
        # ÏïåÎ¶º Í∏∞Î°ù
        if self.system_metrics:
            if 'alerts' not in self.system_metrics[-1]:
                self.system_metrics[-1]['alerts'] = []
            self.system_metrics[-1]['alerts'].append(alert)
        
        # ÏΩúÎ∞± Ïã§Ìñâ
        for callback in self.alert_callbacks:
            try:
                callback(alert)
            except Exception as e:
                logger.error(f"ÏïåÎ¶º ÏΩúÎ∞± Ïã§Ìñâ Ïã§Ìå®: {e}")
    
    def add_alert_callback(self, callback: callable):
        """ÏïåÎ¶º ÏΩúÎ∞± Ï∂îÍ∞Ä"""
        self.alert_callbacks.append(callback)
    
    def set_threshold(self, metric: str, value: float):
        """ÏûÑÍ≥ÑÍ∞í ÏÑ§Ï†ï"""
        if metric in self.thresholds:
            self.thresholds[metric] = value
            logger.info(f"ÏûÑÍ≥ÑÍ∞í Î≥ÄÍ≤Ω: {metric} = {value}")
        else:
            logger.warning(f"Ïïå Ïàò ÏóÜÎäî Î©îÌä∏Î¶≠: {metric}")

# Ï†ÑÏó≠ Î™®ÎãàÌÑ∞ Ïù∏Ïä§ÌÑ¥Ïä§
global_monitor = PerformanceMonitor()

# Ïª®ÌÖçÏä§Ìä∏ Îß§ÎãàÏ†Ä
class OperationMonitor:
    """ÏûëÏóÖ Î™®ÎãàÌÑ∞ÎßÅ Ïª®ÌÖçÏä§Ìä∏ Îß§ÎãàÏ†Ä"""
    
    def __init__(self, operation_name: str, monitor: PerformanceMonitor = None):
        self.operation_name = operation_name
        self.monitor = monitor or global_monitor
        self.operation_id = None
    
    def __enter__(self):
        self.operation_id = self.monitor.record_operation_start(self.operation_name)
        return self.operation_id
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        success = exc_type is None
        details = {}
        
        if exc_type:
            details['error_type'] = exc_type.__name__
            details['error_message'] = str(exc_val)
        
        self.monitor.record_operation_end(self.operation_id, success, details)