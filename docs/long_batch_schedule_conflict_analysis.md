# 장시간 배치 작업과 24시간 주기 스케줄 충돌 분석

## 시나리오 분석

### 가정 상황
- **배치 작업 구성**: 31, 32, 33, 61, 62, 63 단계를 계정1에서 순차 진행
- **예상 소요시간**: 30시간 (타임아웃 기준), 실제 26시간 소요 예상
- **스케줄 설정**: 매일 01:00 시작
- **문제 상황**: 26시간 > 24시간 (스케줄 간격)

## 현재 시스템의 동작 방식

### 1. 삼중 안전장치 중복 실행 방지 시스템

#### A. 스케줄러 레벨 (1차 방지)
```python
def safe_callback():
    # 1. 실행 상태 확인
    if self.is_callback_running:
        logger.warning("이전 주기적 실행이 아직 진행 중입니다. 중복 실행을 방지합니다.")
        return
    
    # 2. 시간 기반 중복 방지 (1시간 이내)
    if self.last_execution_time:
        time_diff = current_time - self.last_execution_time
        if time_diff.total_seconds() < 3600:  # 1시간
            logger.warning(f"최근 실행 후 {time_diff.total_seconds():.0f}초 경과. 중복 실행을 방지합니다.")
            return
```

#### B. 배치 실행 레벨 (2차 방지)
```python
def _execute_periodic_batch(self) -> bool:
    if self.is_executing:
        self._log("이미 실행 중입니다. 중복 실행을 방지합니다.")
        return False
```

#### C. 프로세스 레벨 (3차 방지)
```python
# 실행 중인 프로세스가 있으면 중복 실행 방지
with self.process_lock:
    if self.running_processes:
        active_processes = [p for p in self.running_processes if p.poll() is None]
        if active_processes:
            self._log(f"실행 중인 프로세스 {len(active_processes)}개가 있습니다. 중복 실행을 방지합니다.")
            return False
```

### 2. 구체적인 시나리오별 동작

#### 시나리오 1: 1일차 01:00 시작 → 2일차 03:00 완료

**타임라인:**
- **1일차 01:00**: 첫 번째 배치 시작
- **2일차 01:00**: 스케줄러가 두 번째 실행 시도
  - `is_callback_running = True` (아직 첫 번째 실행 중)
  - **결과**: "이전 주기적 실행이 아직 진행 중입니다. 중복 실행을 방지합니다."
  - **동작**: 두 번째 실행 **건너뜀**
- **2일차 03:00**: 첫 번째 배치 완료
  - `is_callback_running = False`로 변경
  - `last_execution_time` 업데이트
- **3일차 01:00**: 스케줄러가 세 번째 실행 시도
  - `is_callback_running = False` ✅
  - `time_diff = 22시간` (> 1시간) ✅
  - **결과**: 정상 실행

#### 시나리오 2: 연속적인 장시간 배치

**1주일 스케줄 예시:**
```
월요일 01:00 시작 → 화요일 03:00 완료 (26시간)
화요일 01:00 스케줄 → 건너뜀 (실행 중)
수요일 01:00 시작 → 목요일 03:00 완료 (26시간)
목요일 01:00 스케줄 → 건너뜀 (실행 중)
금요일 01:00 시작 → 토요일 03:00 완료 (26시간)
```

**실제 실행 패턴**: 격일 실행 (48시간 간격)

## 시간 기반 중복 방지의 한계

### 현재 설정의 문제점

```python
if time_diff.total_seconds() < 3600:  # 1시간
```

**문제**: 1시간은 너무 짧음
- 26시간 배치 완료 후 22시간 후에 다음 스케줄이 오면 정상 실행
- 하지만 실제로는 시스템 부하, 정리 시간 등을 고려해야 함

### 개선 필요성

**권장 최소 간격**: 4-6시간
```python
if time_diff.total_seconds() < 14400:  # 4시간
    # 또는
if time_diff.total_seconds() < 21600:  # 6시간
```

## 실제 운영 시나리오 분석

### Case 1: 정상적인 26시간 소요

| 일자 | 스케줄 시간 | 실제 동작 | 완료 시간 | 다음 실행 |
|------|-------------|-----------|-----------|----------|
| 1일 | 01:00 | ✅ 실행 시작 | - | - |
| 2일 | 01:00 | ❌ 건너뜀 (실행중) | 03:00 완료 | - |
| 3일 | 01:00 | ✅ 실행 시작 | - | - |
| 4일 | 01:00 | ❌ 건너뜀 (실행중) | 03:00 완료 | - |

**결과**: 48시간 간격으로 실행 (격일 실행)

### Case 2: 네트워크 지연으로 30시간 소요

| 일자 | 스케줄 시간 | 실제 동작 | 완료 시간 | 다음 실행 |
|------|-------------|-----------|-----------|----------|
| 1일 | 01:00 | ✅ 실행 시작 | - | - |
| 2일 | 01:00 | ❌ 건너뜀 (실행중) | 07:00 완료 | - |
| 3일 | 01:00 | ✅ 실행 시작 | - | - |
| 4일 | 01:00 | ❌ 건너뜀 (실행중) | 07:00 완료 | - |

**결과**: 여전히 48시간 간격으로 실행

### Case 3: 타임아웃으로 조기 종료 (일부 단계 실패)

| 일자 | 스케줄 시간 | 실제 동작 | 완료 시간 | 다음 실행 |
|------|-------------|-----------|-----------|----------|
| 1일 | 01:00 | ✅ 실행 시작 | - | - |
| 2일 | 01:00 | ❌ 건너뜀 (실행중) | 01:30 타임아웃 | - |
| 2일 | 02:30 | - | - | 다음 스케줄까지 22.5시간 |
| 3일 | 01:00 | ✅ 실행 시작 | - | - |

**결과**: 정상적인 24시간 간격으로 복구

## 권장 운영 방안

### 1. 스케줄 시간 조정 (권장)

#### A. 48시간 간격 스케줄
```python
# 격일 실행으로 변경
schedule.every(2).days.at("01:00").do(callback)
```

**장점:**
- 26시간 배치와 충돌 없음
- 시스템 안정성 향상
- 예측 가능한 실행 패턴

**단점:**
- 실행 빈도 감소

#### B. 30시간 간격 스케줄
```python
# 30시간마다 실행
# 사용자 정의 스케줄러 필요
```

### 2. 배치 작업 최적화 (권장)

#### A. 단계 분할
```python
# 그룹 1: 31, 32, 33 (키워드 검색 단계)
# 그룹 2: 61, 62, 63 (마켓 업로드 단계)
# 각 그룹을 12시간 간격으로 실행
```

#### B. 병렬 처리 강화
```python
# 현재: 단계별 순차 실행
# 개선: 31, 32, 33을 동시 실행 (서버별 분산)
```

### 3. 시간 기반 중복 방지 강화

#### 현재 코드 수정
```python
# 기존
if time_diff.total_seconds() < 3600:  # 1시간

# 개선
if time_diff.total_seconds() < 21600:  # 6시간
    logger.warning(f"최근 실행 후 {time_diff.total_seconds():.0f}초 경과. 최소 6시간 간격 필요.")
    return
```

### 4. 동적 스케줄 조정 (고급)

```python
def calculate_next_schedule_time(self, last_completion_time, estimated_duration):
    """마지막 완료 시간과 예상 소요 시간을 기반으로 다음 스케줄 계산"""
    # 최소 6시간 간격 보장
    min_interval = timedelta(hours=6)
    # 예상 소요 시간의 1.2배 간격 보장
    safe_interval = timedelta(seconds=estimated_duration * 1.2)
    
    next_time = last_completion_time + max(min_interval, safe_interval)
    return next_time
```

## 현재 시스템의 답변

### 질문에 대한 직접적인 답변

> "01:00 시에 시작한 경우, 그 다음날은 01:00에 시작되는 것인가?"

**답변**: **아니오. 건너뜁니다.**

> "아직 어제 실행한 배치작업이 종료되지 않았으므로, 종료될 때까지 기다렸다가 02:00에 시작되는 것인가?"

**답변**: **아니오. 기다리지 않고 건너뜁니다.**

> "아니면 01:00이 아니니까 그 다음날에 시작되는 것인가?"

**답변**: **예. 그 다음날 01:00에 시작됩니다.** (48시간 후)

### 구체적인 동작 순서

1. **1일차 01:00**: 배치 시작
2. **2일차 01:00**: 스케줄러 실행 시도
   - `is_callback_running = True` 확인
   - "이전 주기적 실행이 아직 진행 중입니다" 로그 출력
   - **즉시 종료** (대기하지 않음)
3. **2일차 03:00**: 배치 완료
   - `is_callback_running = False`로 변경
4. **3일차 01:00**: 다음 배치 정상 시작

## 로그 예시

### 정상적인 26시간 배치 시나리오

```
[2024-01-01 01:00:00] 주기적 실행 시작: 2024-01-01 01:00:00
[2024-01-01 01:00:01] 배치 실행 시작: 1단계=300개, 나머지단계=100개
[2024-01-01 01:00:02] 계정 계정1 처리 시작 (독립 프로세스)
...
[2024-01-02 01:00:00] 이전 주기적 실행이 아직 진행 중입니다. 중복 실행을 방지합니다.
...
[2024-01-02 03:00:00] 주기적 실행 완료: 2024-01-02 03:00:00
[2024-01-03 01:00:00] 주기적 실행 시작: 2024-01-03 01:00:00
```

## 결론 및 권장사항

### 현재 시스템의 장점
1. **완벽한 중복 실행 방지**: 삼중 안전장치로 모든 경우 차단
2. **예측 가능한 동작**: 명확한 규칙에 따른 일관된 동작
3. **시스템 안정성**: 리소스 과부하 방지

### 26시간 배치에 대한 최적 해결책

#### 즉시 적용 가능 (권장)
1. **48시간 간격 스케줄로 변경**
   - `schedule.every(2).days.at("01:00").do(callback)`
   - 충돌 없는 안정적 운영

#### 중장기 개선 (선택)
1. **배치 작업 분할**
   - 31,32,33 그룹과 61,62,63 그룹으로 분리
   - 각각 12시간 간격으로 실행

2. **시간 기반 중복 방지 강화**
   - 1시간 → 6시간으로 변경
   - 더 안전한 간격 보장

### 최종 답변

**현재 시스템에서 26시간 소요 배치는 격일(48시간 간격)로 실행됩니다.**
- 2일차 01:00 스케줄은 자동으로 건너뛰어집니다
- 3일차 01:00에 다음 배치가 시작됩니다
- 이는 시스템의 안전장치가 정상 작동하는 것입니다

**권장**: 스케줄을 48시간 간격으로 변경하여 더 예측 가능하고 안정적인 운영을 하시기 바랍니다.