# 1단계 중복 실행 발생 원인 분석 (9개 스텝 추가 후)

## 문제 상황 재정리
- **발생 시점**: 9개 스텝(311, 312, 313, 321, 322, 323, 331, 332, 333) 추가 후
- **중복 실행 단계**: 1단계만 중복 실행 발생
- **실제 시나리오**: 
  - 21:43 - 첫 번째 스케줄 실행 (7개 계정 × 500개 아이템)
  - 22:43 - 두 번째 스케줄 시간 도래 (이전 실행 아직 진행 중)
  - 결과: 동일한 1단계가 두 번 실행됨
- **배치 주기**: 모든 단계 24시간마다 실행 (62단계만 48시간)
- **1단계 기본 배치수량**: 500개

## 코드 분석을 통한 진짜 원인 발견

### 1. GUI 스텝 순서 정의의 문제점

#### GUI에서 정의된 스텝 순서 (percenty_gui_advanced.py:1543)
```python
step_order = ['1', '51', '52', '53', '21', '22', '23', '4', '31', '32', '33', '311', '312', '313', '321', '322', '323', '331', '332', '333', '61', '62', '63']
```

#### 문제점 분석
- **1단계가 맨 앞에 위치**: 스텝 순서에서 첫 번째로 실행
- **9개 스텝 추가로 전체 스텝 수 증가**: 15개 → 24개 (60% 증가)
- **1단계 실행 시간 vs 스케줄 간격**: 1시간 간격으로 스케줄되지만 1단계 실행이 1시간을 초과할 가능성

### 2. 1단계 특성과 중복 실행 조건

#### 1단계의 실행 특성
```python
# periodic_execution_manager.py:384에서 확인
continue_on_timeout_steps = ['21', '22', '23', '31', '32', '33', '311', '312', '313', '321', '322', '323', '331', '332', '333']
```

**핵심 발견**: **1단계는 continue_on_timeout_steps에 포함되지 않음**
- **1단계**: 타임아웃 시 후속 단계 중단 (엄격한 실행)
- **다른 단계들**: 타임아웃 시에도 후속 단계 계속 진행

#### 1단계 타임아웃 설정
```python
# _calculate_chunk_timeout 함수에서
'1': 195,  # 195초/아이템 (3.25분/아이템)
```

### 3. 중복 실행 발생 시나리오 재구성

#### 시나리오: 9개 스텝 추가 후 1단계 중복 실행
```
상황 설정:
- 주기적 실행 시간: 매일 21:43
- 선택된 스텝: ['1'] (1단계만 선택)
- 1단계 배치 수량: 2개
- 계정 수: 7개

실행 과정:
1. 21:43 - 첫 번째 스케줄 실행 시작
   - 7개 계정 × 1단계 × 2개 아이템 = 총 14개 아이템 처리
   - 예상 시간: 14 × 195초 = 2730초 (45.5분)
   - 실제 시간: 네트워크 지연, 브라우저 로딩 등으로 60-90분 소요 가능

2. 22:43 - 두 번째 스케줄 시간 도래
   - 이전 1단계 실행이 아직 진행 중
   - 수정 전: 중복 실행 방지 로직 부재로 새로운 1단계 실행 시작
   - 결과: 동일한 1단계가 두 번 실행됨
```

### 4. 9개 스텝 추가가 문제를 악화시킨 이유

#### 설정 복잡도 증가의 영향
1. **GUI 설정 처리 시간 증가**:
   ```python
   # 24개 스텝의 청크 사이즈 설정 처리
   chunk_sizes = {
       '1': 20, '21': 10, '22': 10, '23': 10,
       '31': 2, '32': 2, '33': 2,
       '311': 2, '312': 2, '313': 2,  # 새로 추가
       '321': 2, '322': 2, '323': 2,  # 새로 추가
       '331': 2, '332': 2, '333': 2,  # 새로 추가
       # ... 기타 설정들
   }
   ```

2. **스케줄러 재등록 과정의 타이밍 이슈**:
   - GUI에서 설정 저장/로드 시간 증가
   - 스케줄러 중지 → 새 스케줄 등록 과정에서 지연 발생
   - 기존 스케줄러 스레드 완전 종료 전에 새 스레드 시작 가능성 증가

#### 수정 전 ScheduleManager의 취약점
```python
# 수정 전 start_daily_schedule 메서드 (추정)
def start_daily_schedule(self, time_str: str, callback: Callable):
    # 기존 스케줄 정리
    schedule.clear()  # ✅ 스케줄은 정리됨
    
    # 새 스케줄 등록
    schedule.every().day.at(time_str).do(callback)  # ❌ 원본 콜백 직접 사용
    
    # 스케줄러 스레드 시작
    self.scheduler_thread = threading.Thread(target=self._run_scheduler)
    self.scheduler_thread.start()  # ❌ 기존 스레드 종료 확인 없이 새 스레드 시작
```

**문제점**:
1. **콜백 중복 실행 방지 없음**: 원본 콜백을 직접 등록
2. **스레드 상태 확인 없음**: 기존 스케줄러 스레드 종료 확인 없이 새 스레드 시작
3. **실행 상태 추적 없음**: 콜백이 실행 중인지 확인하지 않음

### 5. 왜 61, 62, 63단계에서는 문제가 없었나?

#### 디버깅 단계의 특성
1. **수동 실행 위주**: 자동 스케줄링보다는 수동 테스트
2. **설정 변경 빈도 낮음**: 한 번 설정 후 변경 없이 테스트
3. **스케줄러 재등록 최소화**: 설정 변경이 적어 스케줄러 재시작 빈도 낮음
4. **긴 타임아웃**: 12000초(200분)로 스케줄 간격 내 완료 보장

### 6. 수정된 코드의 해결 방안

#### 삼중 안전장치 구현
```python
# 1. 스케줄러 레벨 중복 방지
def safe_callback():
    if self.is_callback_running:  # 실행 상태 확인
        return
    
    if self.last_execution_time:  # 시간 기반 중복 방지
        time_diff = current_time - self.last_execution_time
        if time_diff.total_seconds() < 3600:
            return
    
    self.is_callback_running = True
    try:
        callback()
    finally:
        self.is_callback_running = False

# 2. 배치 실행 레벨 중복 방지
def _execute_periodic_batch(self):
    if self.is_executing:  # 배치 실행 상태 확인
        return False
    
    with self.process_lock:  # 프로세스 상태 확인
        if self.running_processes:
            active_processes = [p for p in self.running_processes if p.poll() is None]
            if active_processes:
                return False

# 3. 스케줄 정리 강화
def stop_schedule(self):
    self.is_running = False
    schedule.clear()
    # 콜백 상태 초기화
    self.is_callback_running = False
    self.last_execution_time = None
```

## 결론

### 진짜 원인
1. **1단계의 특수성**: continue_on_timeout_steps에 포함되지 않아 엄격한 실행 시간 제약
2. **스케줄 간격 vs 실행 시간**: 1시간 스케줄 간격보다 실제 실행 시간이 길어질 가능성
3. **9개 스텝 추가로 인한 복잡도 증가**: 설정 처리 시간 증가 → 스케줄러 재등록 과정에서 타이밍 이슈
4. **수정 전 중복 방지 로직 부재**: 스케줄러 레벨에서 콜백 중복 실행 방지 없음

### 1단계가 가장 단순함에도 문제가 된 이유
- **실행 순서**: 스텝 순서에서 첫 번째로 실행되어 스케줄 시간에 가장 먼저 시작
- **엄격한 타임아웃**: 다른 단계와 달리 타임아웃 시 후속 단계 중단
- **실행 시간 변동성**: 단순하지만 네트워크 의존성으로 인한 실행 시간 편차

### 수정 효과
- **삼중 안전장치**로 모든 경우의 중복 실행 완전 방지
- **스케줄러 상태 추적**으로 스레드 레벨 중복 등록 방지
- **프로세스 레벨 보호**로 최종 안전망 제공

이제 스텝 수가 더 증가하더라도 중복 실행 문제가 발생하지 않습니다.